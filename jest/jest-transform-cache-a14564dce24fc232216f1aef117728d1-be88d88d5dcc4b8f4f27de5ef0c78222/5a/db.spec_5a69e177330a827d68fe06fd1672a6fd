'use strict';var _slicedToArray = function () {function sliceIterator(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"]) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}return function (arr, i) {if (Array.isArray(arr)) {return arr;} else if (Symbol.iterator in Object(arr)) {return sliceIterator(arr, i);} else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};var _chai = require('chai');var _chai2 = _interopRequireDefault(_chai);
var _chaiAsPromised = require('chai-as-promised');var _chaiAsPromised2 = _interopRequireDefault(_chaiAsPromised);
var _src = require('../src');
var _config = require('./databases/config');var _config2 = _interopRequireDefault(_config);
var _setup = require('./databases/sqlite/setup');var _setup2 = _interopRequireDefault(_setup);
var _setup3 = require('./databases/cassandra/setup');var _setup4 = _interopRequireDefault(_setup3);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}

_chai2.default.use(_chaiAsPromised2.default);

/**
                                               * List of supported DB clients.
                                               * The "integration" tests will be executed for all supported DB clients.
                                               * And ensure all these clients has the same API and output results.
                                               */
const SUPPORTED_DB_CLIENTS = [
'mysql',
'postgresql',
'sqlserver',
'sqlite',
'cassandra'];


const dbSchemas = {
  postgresql: 'public',
  sqlserver: 'dbo' };



/**
                       * List of selected databases to be tested in the current task
                       */
const dbsToTest = (process.env.DB_CLIENTS || '').split(',').filter(client => !!client);


describe('db', () => {
  const dbClients = dbsToTest.length ? dbsToTest : SUPPORTED_DB_CLIENTS;
  if (dbClients.some(dbClient => !~SUPPORTED_DB_CLIENTS.indexOf(dbClient))) {
    throw new Error('Invalid selected db client for tests');
  }

  if (~dbClients.indexOf('sqlite')) {
    (0, _setup2.default)(_config2.default.sqlite);
  } else if (~dbClients.indexOf('cassandra')) {
    (0, _setup4.default)(_config2.default.cassandra);
  }

  dbClients.forEach(dbClient => {
    const dbSchema = dbSchemas[dbClient];

    describe(dbClient, () => {
      describe('.connect', () => {
        it(`should connect into a ${dbClient} database`, () => {
          const serverInfo = _extends({},
          _config2.default[dbClient], {
            name: dbClient,
            client: dbClient });


          const serverSession = _src.db.createServer(serverInfo);
          const dbConn = serverSession.createConnection(serverInfo.database);

          return (0, _chai.expect)(dbConn.connect()).to.not.be.rejected;
        });

        it('should connect into server without database specified', () => {
          const serverInfo = _extends({},
          _config2.default[dbClient], {
            database: _src.db.CLIENTS.find(c => c.key === dbClient).defaultDatabase,
            name: dbClient,
            client: dbClient });


          const serverSession = _src.db.createServer(serverInfo);
          const dbConn = serverSession.createConnection(serverInfo.database);

          return (0, _chai.expect)(dbConn.connect()).to.not.be.rejected;
        });
      });

      describe('given is already connected', () => {
        const serverInfo = _extends({},
        _config2.default[dbClient], {
          name: dbClient,
          client: dbClient });


        let serverSession;
        let dbConn;
        beforeEach(() => {
          serverSession = _src.db.createServer(serverInfo);
          dbConn = serverSession.createConnection(serverInfo.database);
          return dbConn.connect();
        });

        describe('.disconnect', () => {
          it('should close all connections in the pool', () => {
            dbConn.disconnect();
          });
        });

        describe('.listDatabases', () => {
          it('should list all databases', _asyncToGenerator(function* () {
            const databases = yield dbConn.listDatabases();
            if (dbClient === 'sqlite') {
              (0, _chai.expect)(databases[0]).to.match(/sqlectron\.db$/);
            } else {
              (0, _chai.expect)(databases).to.include.members(['sqlectron']);
            }
          }));
        });

        describe('.listTables', () => {
          it('should list all tables', _asyncToGenerator(function* () {
            const tables = yield dbConn.listTables({ schema: dbSchema });
            if (dbClient === 'postgresql' || dbClient === 'sqlserver') {
              (0, _chai.expect)(tables).to.eql([
              { schema: dbSchema, name: 'roles' },
              { schema: dbSchema, name: 'users' }]);

            } else {
              (0, _chai.expect)(tables).to.eql([
              { name: 'roles' },
              { name: 'users' }]);

            }
          }));
        });

        if (dbClient !== 'cassandra') {
          describe('.listViews', () => {
            it('should list all views', _asyncToGenerator(function* () {
              const views = yield dbConn.listViews({ schema: dbSchema });
              if (dbClient === 'postgresql' || dbClient === 'sqlserver') {
                (0, _chai.expect)(views).to.eql([
                { schema: dbSchema, name: 'email_view' }]);

              } else {
                (0, _chai.expect)(views).to.eql([
                { name: 'email_view' }]);

              }
            }));
          });
        }

        describe('.listRoutines', () => {
          it('should list all routines with their type', _asyncToGenerator(function* () {
            const routines = yield dbConn.listRoutines({ schema: dbSchema });
            const routine = dbClient === 'postgresql' ? routines[1] : routines[0];

            // Postgresql routine type is always function. SP do not exist
            // Futhermore, PostgreSQL is expected to have two functions in schema, because
            // additional one is needed for trigger
            if (dbClient === 'postgresql') {
              (0, _chai.expect)(routines).to.have.length(2);
              (0, _chai.expect)(routine).to.have.deep.property('routineType').to.eql('FUNCTION');
              (0, _chai.expect)(routine).to.have.deep.property('schema').to.eql(dbSchema);
            } else if (dbClient === 'mysql') {
              (0, _chai.expect)(routines).to.have.length(1);
              (0, _chai.expect)(routine).to.have.deep.property('routineType').to.eql('PROCEDURE');
              (0, _chai.expect)(routine).to.not.have.deep.property('schema');
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(routines).to.have.length(1);
              (0, _chai.expect)(routine).to.have.deep.property('routineType').to.eql('PROCEDURE');
              (0, _chai.expect)(routine).to.have.deep.property('schema').to.eql(dbSchema);
            } else if (dbClient === 'cassandra' || dbClient === 'sqlite') {
              (0, _chai.expect)(routines).to.have.length(0);
            } else {
              throw new Error('Invalid db client');
            }
          }));
        });

        describe('.listTableColumns', () => {
          it('should list all columns and their type from users table', _asyncToGenerator(function* () {
            const columns = yield dbConn.listTableColumns('users');
            (0, _chai.expect)(columns).to.have.length(6);

            const column = function (name) {return columns.find(function (col) {return col.columnName === name;});};

            /* eslint no-unused-expressions:0 */
            (0, _chai.expect)(column('id')).to.exist;
            (0, _chai.expect)(column('username')).to.exist;
            (0, _chai.expect)(column('email')).to.exist;
            (0, _chai.expect)(column('password')).to.exist;
            (0, _chai.expect)(column('role_id')).to.exist;
            (0, _chai.expect)(column('createdat')).to.exist;

            if (dbClient === 'sqlite') {
              (0, _chai.expect)(column('id')).to.have.property('dataType').to.have.string('INTEGER');
            } else {
              (0, _chai.expect)(column('id')).to.have.property('dataType').to.have.string('int');
            }

            // Each database may have different db types
            if (dbClient === 'postgresql') {
              (0, _chai.expect)(column('username')).to.have.property('dataType').to.eql('text');
              (0, _chai.expect)(column('email')).to.have.property('dataType').to.eql('text');
              (0, _chai.expect)(column('password')).to.have.property('dataType').to.eql('text');
              (0, _chai.expect)(column('role_id')).to.have.property('dataType').to.eql('integer');
              (0, _chai.expect)(column('createdat')).to.have.property('dataType').to.eql('date');
            } else if (dbClient === 'sqlite') {
              (0, _chai.expect)(column('username')).to.have.property('dataType').to.eql('VARCHAR(45)');
              (0, _chai.expect)(column('email')).to.have.property('dataType').to.eql('VARCHAR(150)');
              (0, _chai.expect)(column('password')).to.have.property('dataType').to.eql('VARCHAR(45)');
              (0, _chai.expect)(column('role_id')).to.have.property('dataType').to.eql('INT');
              (0, _chai.expect)(column('createdat')).to.have.property('dataType').to.eql('DATETIME');
            } else if (dbClient === 'cassandra') {
              (0, _chai.expect)(column('username')).to.have.property('dataType').to.eql('text');
              (0, _chai.expect)(column('email')).to.have.property('dataType').to.eql('text');
              (0, _chai.expect)(column('password')).to.have.property('dataType').to.eql('text');
              (0, _chai.expect)(column('role_id')).to.have.property('dataType').to.eql('int');
              (0, _chai.expect)(column('createdat')).to.have.property('dataType').to.eql('timestamp');
            } else {
              (0, _chai.expect)(column('username')).to.have.property('dataType').to.eql('varchar');
              (0, _chai.expect)(column('email')).to.have.property('dataType').to.eql('varchar');
              (0, _chai.expect)(column('password')).to.have.property('dataType').to.eql('varchar');
              (0, _chai.expect)(column('role_id')).to.have.property('dataType').to.eql('int');
              (0, _chai.expect)(column('createdat')).to.have.property('dataType').to.eql('datetime');
            }
          }));
        });

        describe('.listTableTriggers', () => {
          it('should list all table related triggers', _asyncToGenerator(function* () {
            const triggers = yield dbConn.listTableTriggers('users');
            if (dbClient === 'cassandra') {
              (0, _chai.expect)(triggers).to.have.length(0);
            } else {
              (0, _chai.expect)(triggers).to.have.length(1);
              (0, _chai.expect)(triggers).to.include.members(['dummy_trigger']);
            }
          }));
        });

        describe('.listTableIndexes', () => {
          it('should list all indexes', _asyncToGenerator(function* () {
            const indexes = yield dbConn.listTableIndexes('users', dbSchema);
            if (dbClient === 'cassandra') {
              (0, _chai.expect)(indexes).to.have.length(0);
            } else if (dbClient === 'sqlite') {
              (0, _chai.expect)(indexes).to.have.length(1);
              (0, _chai.expect)(indexes).to.include.members(['users_id_index']);
            } else if (dbClient === 'postgresql') {
              (0, _chai.expect)(indexes).to.have.length(1);
              (0, _chai.expect)(indexes).to.include.members(['users_pkey']);
            } else if (dbClient === 'mysql') {
              (0, _chai.expect)(indexes).to.have.length(2);
              (0, _chai.expect)(indexes).to.include.members(['PRIMARY', 'role_id']);
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(indexes).to.have.length(1);
              (0, _chai.expect)(indexes[0]).to.match(/^PK__users__/i);
            } else {
              throw new Error('Invalid db client');
            }
          }));
        });

        describe('.listSchemas', () => {
          it('should list all schema', _asyncToGenerator(function* () {
            const schemas = yield dbConn.listSchemas({ schema: { only: [dbSchema, 'dummy_schema'] } });
            if (dbClient === 'postgresql') {
              (0, _chai.expect)(schemas).to.have.length(2);
              (0, _chai.expect)(schemas).to.include.members([dbSchema, 'dummy_schema']);
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(schemas).to.include('dummy_schema');
            } else {
              (0, _chai.expect)(schemas).to.have.length(0);
            }
          }));
        });

        describe('.getTableReferences', () => {
          it('should list all tables that selected table has references to', _asyncToGenerator(function* () {
            const references = yield dbConn.getTableReferences('users');
            if (dbClient === 'cassandra' || dbClient === 'sqlite') {
              (0, _chai.expect)(references).to.have.length(0);
            } else {
              (0, _chai.expect)(references).to.have.length(1);
              (0, _chai.expect)(references).to.include.members(['roles']);
            }
          }));
        });

        describe('.getTableKeys', () => {
          it('should list all tables keys', _asyncToGenerator(function* () {
            const tableKeys = yield dbConn.getTableKeys('users');
            if (dbClient === 'cassandra') {
              (0, _chai.expect)(tableKeys).to.have.length(1);
            } else if (dbClient === 'sqlite') {
              (0, _chai.expect)(tableKeys).to.have.length(0);
            } else {
              (0, _chai.expect)(tableKeys).to.have.length(2);
            }

            tableKeys.forEach(function (key) {
              if (key.keyType === 'PRIMARY KEY') {
                (0, _chai.expect)(key).to.have.property('columnName').to.eql('id');
                (0, _chai.expect)(key).to.have.property('referencedTable').to.be.a('null');
              } else {
                (0, _chai.expect)(key).to.have.property('columnName').to.eql('role_id');
                (0, _chai.expect)(key).to.have.property('referencedTable').to.eql('roles');
                (0, _chai.expect)(key).to.have.property('keyType').to.eql('FOREIGN KEY');
              }
            });
          }));
        });

        describe('.getTableCreateScript', () => {
          it('should return table create script', _asyncToGenerator(function* () {var _ref12 =
            yield dbConn.getTableCreateScript('users'),_ref13 = _slicedToArray(_ref12, 1);const createScript = _ref13[0];

            if (dbClient === 'mysql') {
              (0, _chai.expect)(createScript).to.contain('CREATE TABLE `users` (\n' +
              '  `id` int(11) NOT NULL AUTO_INCREMENT,\n' +
              '  `username` varchar(45) DEFAULT NULL,\n' +
              '  `email` varchar(150) DEFAULT NULL,\n' +
              '  `password` varchar(45) DEFAULT NULL,\n' +
              '  `role_id` int(11) DEFAULT NULL,\n' +
              '  `createdat` datetime DEFAULT NULL,\n' +
              '  PRIMARY KEY (`id`),\n' +
              '  KEY `role_id` (`role_id`),\n' +
              '  CONSTRAINT `users_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`) ON DELETE CASCADE\n' +
              ') ENGINE=InnoDB');
            } else if (dbClient === 'postgresql') {
              (0, _chai.expect)(createScript).to.eql('CREATE TABLE public.users (\n' +
              '  id integer NOT NULL,\n' +
              '  username text NOT NULL,\n' +
              '  email text NOT NULL,\n' +
              '  password text NOT NULL,\n' +
              '  role_id integer NULL,\n' +
              '  createdat date NULL\n' +
              ');\n' +
              '\n' +
              'ALTER TABLE public.users ADD CONSTRAINT users_pkey PRIMARY KEY (id)');

            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(createScript).to.contain('CREATE TABLE users (\r\n' +
              '  id int IDENTITY(1,1) NOT NULL,\r\n' +
              '  username varchar(45)  NULL,\r\n' +
              '  email varchar(150)  NULL,\r\n' +
              '  password varchar(45)  NULL,\r\n' +
              '  role_id int  NULL,\r\n' +
              '  createdat datetime  NULL,\r\n' +
              ')\r\n');
              (0, _chai.expect)(createScript).to.contain('ALTER TABLE users ADD CONSTRAINT PK__users');
              (0, _chai.expect)(createScript).to.contain('PRIMARY KEY (id)');
            } else if (dbClient === 'sqlite') {
              (0, _chai.expect)(createScript).to.eql('CREATE TABLE users (\n' +
              '  id INTEGER NOT NULL,\n' +
              '  username VARCHAR(45) NULL,\n' +
              '  email VARCHAR(150) NULL,\n' +
              '  password VARCHAR(45) NULL,\n' +
              '  role_id INT,\n' +
              '  createdat DATETIME NULL,\n' +
              '  PRIMARY KEY (id),\n' +
              '  FOREIGN KEY (role_id) REFERENCES roles (id)\n)');

            } else if (dbClient === 'cassandra') {
              (0, _chai.expect)(createScript).to.eql(undefined);
            } else {
              throw new Error('Invalid db client');
            }
          }));
        });

        describe('.getTableSelectScript', () => {
          it('should return SELECT table script', _asyncToGenerator(function* () {
            const selectQuery = yield dbConn.getTableSelectScript('users');
            if (dbClient === 'mysql') {
              (0, _chai.expect)(selectQuery).to.eql('SELECT `id`, `username`, `email`, `password`, `role_id`, `createdat` FROM `users`;');
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(selectQuery).to.eql('SELECT [id], [username], [email], [password], [role_id], [createdat] FROM [users];');
            } else if (dbClient === 'postgresql' || dbClient === 'sqlite') {
              (0, _chai.expect)(selectQuery).to.eql('SELECT "id", "username", "email", "password", "role_id", "createdat" FROM "users";');
            } else if (dbClient === 'cassandra') {
              (0, _chai.expect)(selectQuery).to.eql('SELECT "id", "createdat", "email", "password", "role_id", "username" FROM "users";');
            } else {
              throw new Error('Invalid db client');
            }
          }));

          it('should return SELECT table script with schema if defined', _asyncToGenerator(function* () {
            const selectQuery = yield dbConn.getTableSelectScript('users', 'public');
            if (dbClient === 'sqlserver') {
              (0, _chai.expect)(selectQuery).to.eql('SELECT [id], [username], [email], [password], [role_id], [createdat] FROM [public].[users];');
            } else if (dbClient === 'postgresql') {
              (0, _chai.expect)(selectQuery).to.eql('SELECT "id", "username", "email", "password", "role_id", "createdat" FROM "public"."users";');
            }
          }));
        });


        describe('.getTableInsertScript', () => {
          it('should return INSERT INTO table script', _asyncToGenerator(function* () {
            const insertQuery = yield dbConn.getTableInsertScript('users');
            if (dbClient === 'mysql') {
              (0, _chai.expect)(insertQuery).to.eql([
              'INSERT INTO `users` (`id`, `username`, `email`, `password`, `role_id`, `createdat`)\n',
              'VALUES (?, ?, ?, ?, ?, ?);'].
              join(' '));
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(insertQuery).to.eql([
              'INSERT INTO [users] ([id], [username], [email], [password], [role_id], [createdat])\n',
              'VALUES (?, ?, ?, ?, ?, ?);'].
              join(' '));
            } else if (dbClient === 'postgresql' || dbClient === 'sqlite') {
              (0, _chai.expect)(insertQuery).to.eql([
              'INSERT INTO "users" ("id", "username", "email", "password", "role_id", "createdat")\n',
              'VALUES (?, ?, ?, ?, ?, ?);'].
              join(' '));
            } else if (dbClient === 'cassandra') {
              (0, _chai.expect)(insertQuery).to.eql([
              'INSERT INTO "users" ("id", "createdat", "email", "password", "role_id", "username")\n',
              'VALUES (?, ?, ?, ?, ?, ?);'].
              join(' '));
            } else {
              throw new Error('Invalid db client');
            }
          }));

          it('should return INSERT INTO table script with schema if defined', _asyncToGenerator(function* () {
            const insertQuery = yield dbConn.getTableInsertScript('users', 'public');
            if (dbClient === 'sqlserver') {
              (0, _chai.expect)(insertQuery).to.eql([
              'INSERT INTO [public].[users] ([id], [username], [email], [password], [role_id], [createdat])\n',
              'VALUES (?, ?, ?, ?, ?, ?);'].
              join(' '));
            } else if (dbClient === 'postgresql' || dbClient === 'sqlite') {
              (0, _chai.expect)(insertQuery).to.eql([
              'INSERT INTO "public"."users" ("id", "username", "email", "password", "role_id", "createdat")\n',
              'VALUES (?, ?, ?, ?, ?, ?);'].
              join(' '));
            }
          }));
        });

        describe('.getTableUpdateScript', () => {
          it('should return UPDATE table script', _asyncToGenerator(function* () {
            const updateQuery = yield dbConn.getTableUpdateScript('users');
            if (dbClient === 'mysql') {
              (0, _chai.expect)(updateQuery).to.eql([
              'UPDATE `users`\n',
              'SET `id`=?, `username`=?, `email`=?, `password`=?, `role_id`=?, `createdat`=?\n',
              'WHERE <condition>;'].
              join(' '));
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(updateQuery).to.eql([
              'UPDATE [users]\n',
              'SET [id]=?, [username]=?, [email]=?, [password]=?, [role_id]=?, [createdat]=?\n',
              'WHERE <condition>;'].
              join(' '));
            } else if (dbClient === 'postgresql' || dbClient === 'sqlite') {
              (0, _chai.expect)(updateQuery).to.eql([
              'UPDATE "users"\n',
              'SET "id"=?, "username"=?, "email"=?, "password"=?, "role_id"=?, "createdat"=?\n',
              'WHERE <condition>;'].
              join(' '));
            } else if (dbClient === 'cassandra') {
              (0, _chai.expect)(updateQuery).to.eql([
              'UPDATE "users"\n',
              'SET "id"=?, "createdat"=?, "email"=?, "password"=?, "role_id"=?, "username"=?\n',
              'WHERE <condition>;'].
              join(' '));
            } else {
              throw new Error('Invalid db client');
            }
          }));

          it('should return UPDATE table script with schema if defined', _asyncToGenerator(function* () {
            const updateQuery = yield dbConn.getTableUpdateScript('users', 'public');
            if (dbClient === 'sqlserver') {
              (0, _chai.expect)(updateQuery).to.eql([
              'UPDATE [public].[users]\n',
              'SET [id]=?, [username]=?, [email]=?, [password]=?, [role_id]=?, [createdat]=?\n',
              'WHERE <condition>;'].
              join(' '));
            } else if (dbClient === 'postgresql' || dbClient === 'sqlite') {
              (0, _chai.expect)(updateQuery).to.eql([
              'UPDATE "public"."users"\n',
              'SET "id"=?, "username"=?, "email"=?, "password"=?, "role_id"=?, "createdat"=?\n',
              'WHERE <condition>;'].
              join(' '));
            }
          }));
        });

        describe('.getTableDeleteScript', () => {
          it('should return table DELETE script', _asyncToGenerator(function* () {
            const deleteQuery = yield dbConn.getTableDeleteScript('roles');
            if (dbClient === 'mysql') {
              (0, _chai.expect)(deleteQuery).to.contain('DELETE FROM `roles` WHERE <condition>;');
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(deleteQuery).to.contain('DELETE FROM [roles] WHERE <condition>;');
            } else if (dbClient === 'postgresql' || dbClient === 'sqlite') {
              (0, _chai.expect)(deleteQuery).to.contain('DELETE FROM "roles" WHERE <condition>;');
            } else if (dbClient === 'cassandra') {
              (0, _chai.expect)(deleteQuery).to.contain('DELETE FROM "roles" WHERE <condition>;');
            } else {
              throw new Error('Invalid db client');
            }
          }));

          it('should return table DELETE script with schema if defined', _asyncToGenerator(function* () {
            const deleteQuery = yield dbConn.getTableDeleteScript('roles', 'public');
            if (dbClient === 'sqlserver') {
              (0, _chai.expect)(deleteQuery).to.contain('DELETE FROM [public].[roles] WHERE <condition>;');
            } else if (dbClient === 'postgresql') {
              (0, _chai.expect)(deleteQuery).to.contain('DELETE FROM "public"."roles" WHERE <condition>;');
            }
          }));
        });

        describe('.getViewCreateScript', () => {
          it('should return CREATE VIEW script', _asyncToGenerator(function* () {var _ref23 =
            yield dbConn.getViewCreateScript('email_view'),_ref24 = _slicedToArray(_ref23, 1);const createScript = _ref24[0];

            if (dbClient === 'mysql') {
              (0, _chai.expect)(createScript).to.contain([
              'VIEW `email_view`',
              'AS select `users`.`email` AS `email`,`users`.`password` AS `password`',
              'from `users`'].
              join(' '));
            } else if (dbClient === 'postgresql') {
              (0, _chai.expect)(createScript).to.eql([
              'CREATE OR REPLACE VIEW "public".email_view AS',
              ' SELECT users.email,',
              '    users.password',
              '   FROM users;'].
              join('\n'));
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(createScript).to.eql([
              '\nCREATE VIEW dbo.email_view AS',
              'SELECT dbo.users.email, dbo.users.password',
              'FROM dbo.users;\n'].
              join('\n'));
            } else if (dbClient === 'sqlite') {
              (0, _chai.expect)(createScript).to.eql([
              'CREATE VIEW email_view AS',
              '  SELECT users.email, users.password',
              '  FROM users'].
              join('\n'));
            } else if (dbClient === 'cassandra') {
              (0, _chai.expect)(createScript).to.eql(undefined);
            } else {
              throw new Error('Invalid db client');
            }
          }));
        });

        describe('.getRoutineCreateScript', () => {
          it('should return CREATE PROCEDURE/FUNCTION script', _asyncToGenerator(function* () {var _ref26 =
            yield dbConn.getRoutineCreateScript('users_count', 'Procedure'),_ref27 = _slicedToArray(_ref26, 1);const createScript = _ref27[0];

            if (dbClient === 'mysql') {
              (0, _chai.expect)(createScript).to.contain('CREATE DEFINER=');
              (0, _chai.expect)(createScript).to.contain([
              'PROCEDURE `users_count`()',
              'BEGIN',
              '  SELECT COUNT(*) FROM users;',
              'END'].
              join('\n'));
            } else if (dbClient === 'postgresql') {
              (0, _chai.expect)(createScript).to.eql([
              'CREATE OR REPLACE FUNCTION public.users_count()',
              ' RETURNS bigint',
              ' LANGUAGE sql',
              'AS $function$',
              '  SELECT COUNT(*) FROM users AS total;',
              '$function$\n'].
              join('\n'));
            } else if (dbClient === 'sqlserver') {
              (0, _chai.expect)(createScript).to.contain('CREATE PROCEDURE dbo.users_count');
              (0, _chai.expect)(createScript).to.contain('@Count int OUTPUT');
              (0, _chai.expect)(createScript).to.contain('SELECT @Count = COUNT(*) FROM dbo.users');
            } else if (dbClient === 'cassandra' || dbClient === 'sqlite') {
              (0, _chai.expect)(createScript).to.eql(undefined);
            } else {
              throw new Error('Invalid db client');
            }
          }));
        });

        if (dbClient !== 'cassandra') {
          describe('.query', function () {// eslint-disable-line func-names
            this.timeout(15000);

            it('should be able to cancel the current query', done => {
              const sleepCommands = {
                postgresql: 'SELECT pg_sleep(10);',
                mysql: 'SELECT SLEEP(10000);',
                sqlserver: 'WAITFOR DELAY \'00:00:10\'; SELECT 1 AS number',
                sqlite: '' };


              // Since sqlite does not has a query command to sleep
              // we have to do this by selecting a huge data source.
              // This trick maske select from the same table multiple times.
              if (dbClient === 'sqlite') {
                const fromTables = [];
                for (let i = 0; i < 50; i++) {// eslint-disable-line no-plusplus
                  fromTables.push('sqlite_master');
                }
                sleepCommands.sqlite = `SELECT last.name FROM ${fromTables.join(',')} as last`;
              }

              const query = dbConn.query(sleepCommands[dbClient]);
              const executing = query.execute();

              // wait a 5 secs before cancel
              setTimeout(_asyncToGenerator(function* () {
                let error;
                try {
                  yield Promise.all([
                  executing,
                  query.cancel()]);

                } catch (err) {
                  error = err;
                }

                try {
                  (0, _chai.expect)(error).to.exists;
                  (0, _chai.expect)(error.sqlectronError).to.eql('CANCELED_BY_USER');
                  done();
                } catch (err) {
                  done(err);
                }
              }), 5000);
            });
          });
        }

        describe('.executeQuery', () => {
          const includePk = dbClient === 'cassandra';

          beforeEach(_asyncToGenerator(function* () {
            yield dbConn.executeQuery(`
              INSERT INTO roles (${includePk ? 'id,' : ''} name)
              VALUES (${includePk ? '1,' : ''} 'developer')
            `);

            yield dbConn.executeQuery(`
              INSERT INTO users (${includePk ? 'id,' : ''} username, email, password, role_id, createdat)
              VALUES (${includePk ? '1,' : ''} 'maxcnunes', 'maxcnunes@gmail.com', '123456', 1,'2016-10-25')
            `);
          }));

          afterEach(() => dbConn.truncateAllTables());

          describe('SELECT', () => {
            it('should execute an empty query', _asyncToGenerator(function* () {
              try {
                const results = yield dbConn.executeQuery('');
                (0, _chai.expect)(results).to.have.length(0);
              } catch (err) {
                if (dbClient === 'cassandra') {
                  (0, _chai.expect)(err.message).to.eql('line 0:-1 no viable alternative at input \'<EOF>\'');
                } else {
                  throw err;
                }
              }
            }));

            it('should execute an query with only comments', _asyncToGenerator(function* () {
              try {
                const results = yield dbConn.executeQuery('-- my comment');

                // MySQL treats commented query as a non select query
                if (dbClient === 'mysql') {
                  (0, _chai.expect)(results).to.have.length(1);
                } else {
                  (0, _chai.expect)(results).to.have.length(0);
                }
              } catch (err) {
                if (dbClient === 'cassandra') {
                  (0, _chai.expect)(err.message).to.eql('line 1:13 mismatched character \'<EOF>\' expecting set null');
                } else {
                  throw err;
                }
              }
            }));

            it('should execute a single query with empty result', _asyncToGenerator(function* () {
              const results = yield dbConn.executeQuery('select * from users where id = 0');

              (0, _chai.expect)(results).to.have.length(1);var _results = _slicedToArray(
              results, 1);const result = _results[0];

              // MSSQL/SQLite does not return the fields when the result is empty.
              // For those DBs that return the field names even when the result
              // is empty we should ensure all fields are included.
              if (dbClient === 'sqlserver' || dbClient === 'sqlite') {
                (0, _chai.expect)(result).to.have.property('fields').to.eql([]);
              } else {
                const field = function (name) {return result.fields.find(function (item) {return item.name === name;});};

                (0, _chai.expect)(field('id')).to.exist;
                (0, _chai.expect)(field('username')).to.exist;
                (0, _chai.expect)(field('email')).to.exist;
                (0, _chai.expect)(field('password')).to.exist;
              }

              (0, _chai.expect)(result).to.have.property('command').to.eql('SELECT');
              (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
              (0, _chai.expect)(result).to.have.deep.property('rowCount').to.eql(0);
            }));

            it('should execute a single query', _asyncToGenerator(function* () {
              const results = yield dbConn.executeQuery('select * from users');

              (0, _chai.expect)(results).to.have.length(1);var _results2 = _slicedToArray(
              results, 1);const result = _results2[0];
              const field = function (name) {return result.fields.find(function (item) {return item.name === name;});};

              (0, _chai.expect)(field('id')).to.exist;
              (0, _chai.expect)(field('username')).to.exist;
              (0, _chai.expect)(field('email')).to.exist;
              (0, _chai.expect)(field('password')).to.exist;
              (0, _chai.expect)(field('role_id')).to.exist;
              (0, _chai.expect)(field('createdat')).to.exist;

              (0, _chai.expect)(result).to.have.deep.property('rows[0].id').to.eql(1);
              (0, _chai.expect)(result).to.have.deep.property('rows[0].username').to.eql('maxcnunes');
              (0, _chai.expect)(result).to.have.deep.property('rows[0].password').to.eql('123456');
              (0, _chai.expect)(result).to.have.deep.property('rows[0].email').to.eql('maxcnunes@gmail.com');
              (0, _chai.expect)(result).to.have.deep.property('rows[0].createdat');

              (0, _chai.expect)(result).to.have.property('command').to.eql('SELECT');
              (0, _chai.expect)(result).to.have.deep.property('rowCount').to.eql(1);
            }));

            if (dbClient === 'mysql' || dbClient === 'postgresql') {
              it('should not cast DATE types to native JS Date objects', _asyncToGenerator(function* () {
                const results = yield dbConn.executeQuery('select createdat from users');

                (0, _chai.expect)(results).to.have.length(1);var _results3 = _slicedToArray(
                results, 1);const result = _results3[0];

                (0, _chai.expect)(result).to.have.deep.property('fields[0].name').to.eql('createdat');
                (0, _chai.expect)(result).to.have.deep.property('rows[0].createdat').to.match(/^2016-10-25/);
              }));
            }

            it('should execute multiple queries', _asyncToGenerator(function* () {
              try {
                const results = yield dbConn.executeQuery(`
                  select * from users;
                  select * from roles;
                `);

                (0, _chai.expect)(results).to.have.length(2);var _results4 = _slicedToArray(
                results, 2);const firstResult = _results4[0],secondResult = _results4[1];

                (0, _chai.expect)(firstResult).to.have.deep.property('fields[0].name').to.eql('id');
                (0, _chai.expect)(firstResult).to.have.deep.property('fields[1].name').to.eql('username');
                (0, _chai.expect)(firstResult).to.have.deep.property('fields[2].name').to.eql('email');
                (0, _chai.expect)(firstResult).to.have.deep.property('fields[3].name').to.eql('password');

                (0, _chai.expect)(firstResult).to.have.deep.property('rows[0].id').to.eql(1);
                (0, _chai.expect)(firstResult).to.have.deep.property('rows[0].username').to.eql('maxcnunes');
                (0, _chai.expect)(firstResult).to.have.deep.property('rows[0].password').to.eql('123456');
                (0, _chai.expect)(firstResult).to.have.deep.property('rows[0].email').to.eql('maxcnunes@gmail.com');

                (0, _chai.expect)(firstResult).to.have.property('command').to.eql('SELECT');
                (0, _chai.expect)(firstResult).to.have.deep.property('rowCount').to.eql(1);

                (0, _chai.expect)(secondResult).to.have.deep.property('fields[0].name').to.eql('id');
                (0, _chai.expect)(secondResult).to.have.deep.property('fields[1].name').to.eql('name');

                (0, _chai.expect)(secondResult).to.have.deep.property('rows[0].id').to.eql(1);
                (0, _chai.expect)(secondResult).to.have.deep.property('rows[0].name').to.eql('developer');

                (0, _chai.expect)(secondResult).to.have.property('command').to.eql('SELECT');
                (0, _chai.expect)(secondResult).to.have.deep.property('rowCount').to.eql(1);
              } catch (err) {
                if (dbClient === 'cassandra') {
                  (0, _chai.expect)(err.message).to.match(/missing EOF at 'select'/);
                } else {
                  throw err;
                }
              }
            }));
          });

          describe('INSERT', () => {
            it('should execute a single query', _asyncToGenerator(function* () {
              const results = yield dbConn.executeQuery(`
                insert into users (${includePk ? 'id,' : ''} username, email, password)
                values (${includePk ? '1,' : ''} 'user', 'user@hotmail.com', '123456')
              `);

              (0, _chai.expect)(results).to.have.length(1);var _results5 = _slicedToArray(
              results, 1);const result = _results5[0];

              (0, _chai.expect)(result).to.have.property('command').to.eql('INSERT');
              (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
              (0, _chai.expect)(result).to.have.property('fields').to.eql([]);

              // Cassandra does not return affectedRows
              if (dbClient === 'cassandra') {
                (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(undefined);
              } else {
                (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(1);
              }

              // MSSQL does not return row count
              // so this value is based in the number of rows
              if (dbClient === 'sqlserver') {
                (0, _chai.expect)(result).to.have.property('rowCount').to.eql(0);
              } else {
                (0, _chai.expect)(result).to.have.property('rowCount').to.eql(undefined);
              }
            }));

            it('should execute multiple queries', _asyncToGenerator(function* () {
              try {
                const results = yield dbConn.executeQuery(`
                  insert into users (username, email, password)
                  values ('user', 'user@hotmail.com', '123456');

                  insert into roles (name)
                  values ('manager');
                `);

                // MSSQL treats multiple non select queries as a single query result
                if (dbClient === 'sqlserver') {
                  (0, _chai.expect)(results).to.have.length(1);var _results6 = _slicedToArray(
                  results, 1);const result = _results6[0];

                  (0, _chai.expect)(result).to.have.property('command').to.eql('INSERT');
                  (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('rowCount').to.eql(0);
                  (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(2);
                } else {
                  (0, _chai.expect)(results).to.have.length(2);var _results7 = _slicedToArray(
                  results, 2);const firstResult = _results7[0],secondResult = _results7[1];

                  (0, _chai.expect)(firstResult).to.have.property('command').to.eql('INSERT');
                  (0, _chai.expect)(firstResult).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(firstResult).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(firstResult).to.have.property('rowCount').to.eql(undefined);
                  (0, _chai.expect)(firstResult).to.have.property('affectedRows').to.eql(1);

                  (0, _chai.expect)(secondResult).to.have.property('command').to.eql('INSERT');
                  (0, _chai.expect)(secondResult).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(secondResult).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(secondResult).to.have.property('rowCount').to.eql(undefined);
                  (0, _chai.expect)(secondResult).to.have.property('affectedRows').to.eql(1);
                }
              } catch (err) {
                if (dbClient === 'cassandra') {
                  (0, _chai.expect)(err.message).to.match(/missing EOF at 'insert'/);
                } else {
                  throw err;
                }
              }
            }));
          });

          describe('DELETE', () => {
            it('should execute a single query', _asyncToGenerator(function* () {
              const results = yield dbConn.executeQuery(`
                delete from users where id = 1
              `);

              (0, _chai.expect)(results).to.have.length(1);var _results8 = _slicedToArray(
              results, 1);const result = _results8[0];

              (0, _chai.expect)(result).to.have.property('command').to.eql('DELETE');
              (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
              (0, _chai.expect)(result).to.have.property('fields').to.eql([]);

              // Cassandra does not return affectedRows
              if (dbClient === 'cassandra') {
                (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(undefined);
              } else {
                (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(1);
              }

              // MSSQL does not return row count
              // so these value is based in the number of rows
              if (dbClient === 'sqlserver') {
                (0, _chai.expect)(result).to.have.property('rowCount').to.eql(0);
              } else {
                (0, _chai.expect)(result).to.have.property('rowCount').to.eql(undefined);
              }
            }));

            it('should execute multiple queries', _asyncToGenerator(function* () {
              try {
                const results = yield dbConn.executeQuery(`
                  delete from users where username = 'maxcnunes';
                  delete from roles where name = 'developer';
                `);

                // MSSQL treats multiple non select queries as a single query result
                if (dbClient === 'sqlserver') {
                  (0, _chai.expect)(results).to.have.length(1);var _results9 = _slicedToArray(
                  results, 1);const result = _results9[0];

                  (0, _chai.expect)(result).to.have.property('command').to.eql('DELETE');
                  (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('rowCount').to.eql(0);
                  (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(2);
                } else {
                  (0, _chai.expect)(results).to.have.length(2);var _results10 = _slicedToArray(
                  results, 2);const firstResult = _results10[0],secondResult = _results10[1];

                  (0, _chai.expect)(firstResult).to.have.property('command').to.eql('DELETE');
                  (0, _chai.expect)(firstResult).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(firstResult).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(firstResult).to.have.property('rowCount').to.eql(undefined);
                  (0, _chai.expect)(firstResult).to.have.property('affectedRows').to.eql(1);

                  (0, _chai.expect)(secondResult).to.have.property('command').to.eql('DELETE');
                  (0, _chai.expect)(secondResult).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(secondResult).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(secondResult).to.have.property('rowCount').to.eql(undefined);
                  (0, _chai.expect)(secondResult).to.have.property('affectedRows').to.eql(1);
                }
              } catch (err) {
                if (dbClient === 'cassandra') {
                  (0, _chai.expect)(err.message).to.match(/missing EOF at 'delete'/);
                } else {
                  throw err;
                }
              }
            }));
          });

          describe('UPDATE', () => {
            it('should execute a single query', _asyncToGenerator(function* () {
              const results = yield dbConn.executeQuery(`
                update users set username = 'max' where id = 1
              `);

              (0, _chai.expect)(results).to.have.length(1);var _results11 = _slicedToArray(
              results, 1);const result = _results11[0];

              (0, _chai.expect)(result).to.have.property('command').to.eql('UPDATE');
              (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
              (0, _chai.expect)(result).to.have.property('fields').to.eql([]);

              // Cassandra does not return affectedRows
              if (dbClient === 'cassandra') {
                (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(undefined);
              } else {
                (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(1);
              }

              // MSSQL does not return row count
              // so these value is based in the number of rows
              if (dbClient === 'sqlserver') {
                (0, _chai.expect)(result).to.have.property('rowCount').to.eql(0);
              } else {
                (0, _chai.expect)(result).to.have.property('rowCount').to.eql(undefined);
              }
            }));

            it('should execute multiple queries', _asyncToGenerator(function* () {
              try {
                const results = yield dbConn.executeQuery(`
                  update users set username = 'max' where username = 'maxcnunes';
                  update roles set name = 'dev' where name = 'developer';
                `);

                // MSSQL treats multiple non select queries as a single query result
                if (dbClient === 'sqlserver') {
                  (0, _chai.expect)(results).to.have.length(1);var _results12 = _slicedToArray(
                  results, 1);const result = _results12[0];

                  (0, _chai.expect)(result).to.have.property('command').to.eql('UPDATE');
                  (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('rowCount').to.eql(0);
                  (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(2);
                } else {
                  (0, _chai.expect)(results).to.have.length(2);var _results13 = _slicedToArray(
                  results, 2);const firstResult = _results13[0],secondResult = _results13[1];

                  (0, _chai.expect)(firstResult).to.have.property('command').to.eql('UPDATE');
                  (0, _chai.expect)(firstResult).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(firstResult).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(firstResult).to.have.property('rowCount').to.eql(undefined);
                  (0, _chai.expect)(firstResult).to.have.property('affectedRows').to.eql(1);

                  (0, _chai.expect)(secondResult).to.have.property('command').to.eql('UPDATE');
                  (0, _chai.expect)(secondResult).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(secondResult).to.have.property('fields').to.eql([]);
                  (0, _chai.expect)(secondResult).to.have.property('rowCount').to.eql(undefined);
                  (0, _chai.expect)(secondResult).to.have.property('affectedRows').to.eql(1);
                }
              } catch (err) {
                if (dbClient === 'cassandra') {
                  (0, _chai.expect)(err.message).to.match(/missing EOF at 'update'/);
                } else {
                  throw err;
                }
              }
            }));
          });

          if (dbClient !== 'cassandra' && dbClient !== 'sqlite') {
            describe('CREATE', () => {
              describe('DATABASE', () => {
                beforeEach(_asyncToGenerator(function* () {
                  try {
                    yield dbConn.executeQuery('drop database db_test_create_database');
                  } catch (err) {
                    // just ignore
                  }
                }));

                it('should execute a single query', _asyncToGenerator(function* () {
                  const results = yield dbConn.executeQuery('create database db_test_create_database');

                  // MSSQL does not return any information about CREATE queries
                  if (dbClient === 'sqlserver') {
                    (0, _chai.expect)(results).to.have.length(0);
                    return;
                  }

                  (0, _chai.expect)(results).to.have.length(1);var _results14 = _slicedToArray(
                  results, 1);const result = _results14[0];

                  (0, _chai.expect)(result).to.have.property('command').to.eql('CREATE_DATABASE');
                  (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('fields').to.eql([]);
                  // seems each DB client returns a different value for CREATE
                  (0, _chai.expect)(result).to.have.property('affectedRows').to.oneOf([0, 1, undefined]);
                  (0, _chai.expect)(result).to.have.property('rowCount').to.eql(undefined);
                }));
              });
            });
          }

          if (dbClient !== 'cassandra' && dbClient !== 'sqlite') {
            describe('DROP', () => {
              describe('DATABASE', () => {
                beforeEach(_asyncToGenerator(function* () {
                  try {
                    yield dbConn.executeQuery('create database db_test_create_database');
                  } catch (err) {
                    // just ignore
                  }
                }));

                it('should execute a single query', _asyncToGenerator(function* () {
                  const results = yield dbConn.executeQuery('drop database db_test_create_database');

                  // MSSQL does not return any information about DROP queries
                  if (dbClient === 'sqlserver') {
                    (0, _chai.expect)(results).to.have.length(0);
                    return;
                  }

                  (0, _chai.expect)(results).to.have.length(1);var _results15 = _slicedToArray(
                  results, 1);const result = _results15[0];

                  (0, _chai.expect)(result).to.have.property('command').to.eql('DROP_DATABASE');
                  (0, _chai.expect)(result).to.have.property('rows').to.eql([]);
                  (0, _chai.expect)(result).to.have.property('fields').to.eql([]);
                  // seems each DB client returns a different value for DROP
                  (0, _chai.expect)(result).to.have.property('affectedRows').to.oneOf([0, 1, undefined]);
                  (0, _chai.expect)(result).to.have.property('rowCount').to.eql(undefined);
                }));
              });
            });
          }

          if (dbClient === 'postgresql') {
            describe('EXPLAIN', () => {
              it('should execute a single query', _asyncToGenerator(function* () {
                const results = yield dbConn.executeQuery('explain select * from users');

                (0, _chai.expect)(results).to.have.length(1);var _results16 = _slicedToArray(
                results, 1);const result = _results16[0];

                (0, _chai.expect)(result).to.have.property('command').to.eql('EXPLAIN');
                (0, _chai.expect)(result).to.have.property('rows').to.have.length.above(0);
                (0, _chai.expect)(result).to.have.deep.property('fields').to.have.length(1);
                (0, _chai.expect)(result).to.have.deep.property('fields[0].name').to.eql('QUERY PLAN');
                (0, _chai.expect)(result).to.have.property('affectedRows').to.eql(undefined);
                (0, _chai.expect)(result).to.have.property('rowCount').to.eql(undefined);
              }));
            });
          }
        });
      });
    });
  });
});